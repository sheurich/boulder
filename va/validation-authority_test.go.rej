--- va/validation-authority_test.go
+++ va/validation-authority_test.go
@@ -121,18 +112,15 @@ func simpleSrv(t *testing.T, token string, stopChan, waitChan chan bool, enableT
 			PrivateKey:  &TheKey,
 		}
 
-		tlsConfig := &tls.Config{
+		server.TLS = &tls.Config{
 			Certificates: []tls.Certificate{*cert},
 		}
-
-		listener = tls.NewListener(conn, tlsConfig)
+		server.StartTLS()
 	}
-
-	waitChan <- true
-	server.Serve(listener)
+	return server
 }
 
-func dvsniSrv(t *testing.T, R, S []byte, stopChan, waitChan chan bool) {
+func dvsniSrv(t *testing.T, R, S []byte) *httptest.Server {
 	RS := append(R, S...)
 	z := sha256.Sum256(RS)
 	zName := fmt.Sprintf("%064x.acme.invalid", z)
@@ -200,14 +177,16 @@ func TestSimpleHttpTLS(t *testing.T) {
 
 	chall := core.Challenge{Path: "test", Token: expectedToken}
 
-	stopChan := make(chan bool, 1)
-	waitChan := make(chan bool, 1)
-	go simpleSrv(t, expectedToken, stopChan, waitChan, true)
-	defer func() { stopChan <- true }()
-	<-waitChan
+	hs := simpleSrv(t, expectedToken, true)
+	defer hs.Close()
+	u, err := url.Parse(hs.URL)
+	if err != nil {
+		t.Fatalf("unable to parse httptest.Server URL %#v: %#v", hs.URL, err)
+	}
+	idt := core.AcmeIdentifier{Type: core.IdentifierDNS, Value: u.Host}
 
 	log.Clear()
-	finChall, err := va.validateSimpleHTTP(ident, chall)
+	finChall, err := va.validateSimpleHTTP(idt, chall)
 	test.AssertEquals(t, finChall.Status, core.StatusValid)
 	test.AssertNotError(t, err, chall.Path)
 	logs := log.GetAllMatching(`^\[AUDIT\] Attempting to validate SimpleHTTPS for `)
@@ -227,28 +206,30 @@ func TestSimpleHttp(t *testing.T) {
 	test.AssertError(t, err, "Server's not up yet; expected refusal. Where did we connect?")
 	test.AssertEquals(t, invalidChall.Error.Type, core.ConnectionProblem)
 
-	stopChan := make(chan bool, 1)
-	waitChan := make(chan bool, 1)
-	go simpleSrv(t, expectedToken, stopChan, waitChan, tls)
-	defer func() { stopChan <- true }()
-	<-waitChan
+	hs := simpleSrv(t, expectedToken, tls)
+	defer hs.Close()
+	u, err := url.Parse(hs.URL)
+	if err != nil {
+		t.Fatalf("unable to parse httptest.Server URL %#v: %#v", hs.URL, err)
+	}
+	idt := core.AcmeIdentifier{Type: core.IdentifierDNS, Value: u.Host}
 
 	log.Clear()
-	finChall, err := va.validateSimpleHTTP(ident, chall)
+	finChall, err := va.validateSimpleHTTP(idt, chall)
 	test.AssertEquals(t, finChall.Status, core.StatusValid)
 	test.AssertNotError(t, err, chall.Path)
 	test.AssertEquals(t, len(log.GetAllMatching(`^\[AUDIT\] `)), 1)
 
 	log.Clear()
 	chall.Path = pathMoved
-	finChall, err = va.validateSimpleHTTP(ident, chall)
+	finChall, err = va.validateSimpleHTTP(idt, chall)
 	test.AssertEquals(t, finChall.Status, core.StatusValid)
 	test.AssertNotError(t, err, chall.Path)
 	test.AssertEquals(t, len(log.GetAllMatching(`redirect from ".*/301" to ".*/valid"`)), 1)
 
 	log.Clear()
 	chall.Path = pathFound
-	finChall, err = va.validateSimpleHTTP(ident, chall)
+	finChall, err = va.validateSimpleHTTP(idt, chall)
 	test.AssertEquals(t, finChall.Status, core.StatusValid)
 	test.AssertNotError(t, err, chall.Path)
 	test.AssertEquals(t, len(log.GetAllMatching(`redirect from ".*/302" to ".*/301"`)), 1)
@@ -256,20 +237,20 @@ func TestSimpleHttp(t *testing.T) {
 
 	log.Clear()
 	chall.Path = path404
-	invalidChall, err = va.validateSimpleHTTP(ident, chall)
+	invalidChall, err = va.validateSimpleHTTP(idt, chall)
 	test.AssertEquals(t, invalidChall.Status, core.StatusInvalid)
 	test.AssertError(t, err, "Should have found a 404 for the challenge.")
 	test.AssertEquals(t, invalidChall.Error.Type, core.UnauthorizedProblem)
 	test.AssertEquals(t, len(log.GetAllMatching(`^\[AUDIT\] `)), 1)
 
 	chall.Path = pathWrongToken
-	invalidChall, err = va.validateSimpleHTTP(ident, chall)
+	invalidChall, err = va.validateSimpleHTTP(idt, chall)
 	test.AssertEquals(t, invalidChall.Status, core.StatusInvalid)
 	test.AssertError(t, err, "The path should have given us the wrong token.")
 	test.AssertEquals(t, invalidChall.Error.Type, core.UnauthorizedProblem)
 
 	chall.Path = ""
-	invalidChall, err = va.validateSimpleHTTP(ident, chall)
+	invalidChall, err = va.validateSimpleHTTP(idt, chall)
 	test.AssertEquals(t, invalidChall.Status, core.StatusInvalid)
 	test.AssertError(t, err, "Empty paths shouldn't work either.")
 	test.AssertEquals(t, invalidChall.Error.Type, core.MalformedProblem)
@@ -289,20 +270,20 @@ func TestSimpleHttp(t *testing.T) {
 	va.TestMode = true
 
 	chall.Path = pathUnsafe
-	invalidChall, err = va.validateSimpleHTTP(ident, chall)
+	invalidChall, err = va.validateSimpleHTTP(idt, chall)
 	test.AssertEquals(t, invalidChall.Status, core.StatusInvalid)
 	test.AssertError(t, err, "Path doesn't consist of URL-safe characters.")
 	test.AssertEquals(t, invalidChall.Error.Type, core.MalformedProblem)
 
 	chall.Path = pathUnsafe302
-	invalidChall, err = va.validateSimpleHTTP(ident, chall)
+	invalidChall, err = va.validateSimpleHTTP(idt, chall)
 	test.AssertEquals(t, invalidChall.Status, core.StatusInvalid)
 	test.AssertError(t, err, "Redirect should have failed.")
 	test.AssertEquals(t, invalidChall.Error.Type, core.ConnectionProblem)
 
 	chall.Path = "wait-long"
 	started := time.Now()
-	invalidChall, err = va.validateSimpleHTTP(ident, chall)
+	invalidChall, err = va.validateSimpleHTTP(idt, chall)
 	took := time.Since(started)
 	// Check that the HTTP connection times out after 5 seconds and doesn't block for 10 seconds
 	test.Assert(t, (took > (time.Second * 5)), "HTTP timed out before 5 seconds")
@@ -314,28 +295,36 @@ func TestSimpleHttp(t *testing.T) {
 
 func TestDvsni(t *testing.T) {
 	va := NewValidationAuthorityImpl(true)
+	// FIXME
 	va.DNSResolver = &mocks.MockDNS{}
-
 	a := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}
 	ba := core.B64enc(a)
 	chall := core.Challenge{R: ba, S: ba}
 
+	// FIXME tear down server then test this with real idt
 	invalidChall, err := va.validateDvsni(ident, chall)
 	test.AssertEquals(t, invalidChall.Status, core.StatusInvalid)
 	test.AssertError(t, err, "Server's not up yet; expected refusal. Where did we connect?")
 	test.AssertEquals(t, invalidChall.Error.Type, core.ConnectionProblem)
 
-	waitChan := make(chan bool, 1)
-	stopChan := make(chan bool, 1)
-	go dvsniSrv(t, a, a, stopChan, waitChan)
-	defer func() { stopChan <- true }()
-	<-waitChan
+	hs := dvsniSrv(t, a, a)
+	defer hs.Close()
+
+	u, err := url.Parse(hs.URL)
+	if err != nil {
+		t.Fatalf("unable to parse httptest.Server URL %#v: %#v", hs.URL, err)
+	}
+	_, port, err := net.SplitHostPort(u.Host)
+	if err != nil {
+		t.Fatalf("unable to SplitHostPort the httptestServer URL %#v: %#v", hs.URL, err)
+	}
+	idt := core.AcmeIdentifier{Type: core.IdentifierDNS, Value: u.Host}
 
-	finChall, err := va.validateDvsni(ident, chall)
+	finChall, err := va.validateDvsni(idt, chall)
 	test.AssertEquals(t, finChall.Status, core.StatusValid)
 	test.AssertNotError(t, err, "")
 
-	invalidChall, err = va.validateDvsni(core.AcmeIdentifier{Type: core.IdentifierType("ip"), Value: "127.0.0.1"}, chall)
+	invalidChall, err = va.validateDvsni(core.AcmeIdentifier{Type: core.IdentifierType("ip"), Value: net.JoinHostPort("127.0.0.1", port)}, chall)
 	test.AssertEquals(t, invalidChall.Status, core.StatusInvalid)
 	test.AssertError(t, err, "IdentifierType IP shouldn't have worked.")
 	test.AssertEquals(t, invalidChall.Error.Type, core.MalformedProblem)
@@ -348,22 +337,22 @@ func TestDvsni(t *testing.T) {
 
 	va.TestMode = true
 	chall.R = ba[5:]
-	invalidChall, err = va.validateDvsni(ident, chall)
+	invalidChall, err = va.validateDvsni(idt, chall)
 	test.AssertEquals(t, invalidChall.Status, core.StatusInvalid)
 	test.AssertError(t, err, "R Should be illegal Base64")
 	test.AssertEquals(t, invalidChall.Error.Type, core.MalformedProblem)
 
 	chall.R = ba
 	chall.S = "!@#"
-	invalidChall, err = va.validateDvsni(ident, chall)
+	invalidChall, err = va.validateDvsni(idt, chall)
 	test.AssertEquals(t, invalidChall.Status, core.StatusInvalid)
 	test.AssertError(t, err, "S Should be illegal Base64")
 	test.AssertEquals(t, invalidChall.Error.Type, core.MalformedProblem)
 
 	chall.S = ba
-	chall.Nonce = "wait-long"
+	chall.Nonce = "wait-long" // FIXME make a constant to be shared
 	started := time.Now()
-	invalidChall, err = va.validateDvsni(ident, chall)
+	invalidChall, err = va.validateDvsni(idt, chall)
 	took := time.Since(started)
 	// Check that the HTTP connection times out after 5 seconds and doesn't block for 10 seconds
 	test.Assert(t, (took > (time.Second * 5)), "HTTP timed out before 5 seconds")
@@ -427,19 +407,11 @@ func TestValidateDvsni(t *testing.T) {
 	challDvsni := core.DvsniChallenge()
 	challDvsni.S = challDvsni.R
 
-	waitChanDvsni := make(chan bool, 1)
-	stopChanDvsni := make(chan bool, 1)
 	ar, _ := core.B64dec(challDvsni.R)
 	as, _ := core.B64dec(challDvsni.S)
-	go dvsniSrv(t, ar, as, stopChanDvsni, waitChanDvsni)
+	hs := dvsniSrv(t, ar, as)
 
-	// Let them start
-	<-waitChanDvsni
-
-	// shutdown cleanly
-	defer func() {
-		stopChanDvsni <- true
-	}()
+	defer hs.Close()
 
 	var authz = core.Authorization{
 		ID:             core.NewToken(),
@@ -461,19 +433,12 @@ func TestValidateDvsniNotSane(t *testing.T) {
 	challDvsni := core.DvsniChallenge()
 	challDvsni.R = "boulder" // Not a sane thing to do.
 
-	waitChanDvsni := make(chan bool, 1)
-	stopChanDvsni := make(chan bool, 1)
 	ar, _ := core.B64dec(challDvsni.R)
 	as, _ := core.B64dec(challDvsni.S)
-	go dvsniSrv(t, ar, as, stopChanDvsni, waitChanDvsni)
-
-	// Let them start
-	<-waitChanDvsni
+	hs := dvsniSrv(t, ar, as)
 
 	// shutdown cleanly
-	defer func() {
-		stopChanDvsni <- true
-	}()
+	defer hs.Close()
 
 	var authz = core.Authorization{
 		ID:             core.NewToken(),
